---
title: "manipulating time series data with xts and zoo in R"
author: "Daniel Pinedo"
date: "10/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Introducing xts and zoo objects**
___
- What is xts?
  - eXtensible Time Series
  - An extended zoo object
  - Index + Matrix
  - Times + Observations
  
- The xts constructor
  - tzone: time zone of your series
  - unique: forces times to be unique
  - index is in increasing order of time
  
- Special xts behavior
  - xts is a matrix with associated times for each observation
  - subsets preserve matrix form
  - attributes are preserved
    - i.e. a time-stamp that was acquired
  - xts is a subclass of zoo
  
- Deconstructing xts
  - use internal components
  - *coredata(x)* is used to extract the data component
  - *index(x)* to extract the index a.k.a. times
___

**More than a matrix**

It is best to think of xts objects as normal R matrices, but with special powers. These powers let you manipulate your data as a function of time, as your data is now self-aware of when it exists in time. Before we can start to exploit these powers, it will be helpful to see how xts objects relate to their base-R relatives.

In this exercise, you will get a feel for xts and how it behaves like a matrix object. The xts object ex_matrix and matrix object core have been pre-loaded for you.
```{r}
# Load xts
#library(xts)

# View the structure of ex_matrix
#str(ex_matrix)

# Extract the 3rd observation of the 2nd column of ex_matrix
#ex_matrix[3, 2]

# Extract the 3rd observation of the 2nd column of core 
#core[3, 2]

######################################################
## View the structure of ex_matrix
#str(ex_matrix)
#An 'xts' object on 2016-06-01/2016-06-03 containing:
#  Data: num [1:3, 1:2] 1 1 1 2 2 2
#  Indexed by objects of class: [Date] TZ: UTC
#  xts Attributes:  
#List of 1
# $ createdOn: POSIXct[1:1], format: "2020-10-24 18:20:48"
#
# Extract the 3rd observation of the 2nd column of ex_matrix
#ex_matrix[3, 2]
#           [,1]
#2016-06-03    2
#
# Extract the 3rd observation of the 2nd column of core 
#core[3, 2]
#[1] 2
######################################################

```

**Your first xts object**
xts objects are simple. Think of them as a matrix of observations combined with an index of corresponding dates and times.

  xts = matrix + times
  
The main xts constructor takes a number of arguments, but the two most important are x for the data and order.by for the index. x must be a vector or matrix. order.by is a vector which must be the same length or number of rows as x, be a proper time or date object (very important!), and be in increasing order.

xts also allows you to bind arbitrary key-value attributes to your data. This lets you keep metadata about your object inside your object. To add these at creation, you simply pass additional name = value arguments to the xts() function.

Since we are focusing here on the mechanics, we'll use random numbers as our data so we can focus on creating the object rather than worry about its contents.
```{r}
p_load(xts)
# Create the object data using 5 random numbers
data <- rnorm(5)

# Create dates as a Date class object starting from 2016-01-01
dates <- seq(as.Date("2016-01-01"), length = 5, by = "days")

# Use xts() to create smith
smith <- xts(x = data, order.by = dates)

# Create bday (1899-05-08) using a POSIXct date class object
bday <- as.POSIXct("1899-05-08")

# Create hayek and add a new attribute called born
hayek <- xts(x = data, order.by = dates, born = bday)

```

Now that you know how to create a very simple xts object, you are ready to see what the object looks like inside.

**Deconstructing xts**
Now that you can create xts objects, your next task is to examine an xts object from the inside.

At the core of both xts and zoo is a simple R matrix with a few additional attributes. The most important of these attributes is the index. The index holds all the information we need for xts to treat our data as a time series.

When working with time series, it will sometimes be necessary to separate your time series into its core data and index attributes for additional analysis and manipulation. The core data is the matrix portion of xts. You can separate this from the xts object using *coredata()*. The index portion of the xts object is available using the *index()* function. Note that both of these functions are methods from the zoo class, which xts extends.

In this exercise you will use these built-in functions to extract both the internal matrix data and internal index from your sample xts object. You will use the hayek time series you created in the last exercise to practice these new functions.
```{r}
# Extract the core data of hayek
hayek_core <- coredata(hayek)

# View the class of hayek_core
class(hayek_core)

# Extract the index of hayek
hayek_index <- index(hayek)

# View the class of hayek_index
class(hayek_index)
```

**Time based indices**
xts objects get their power from the index attribute that holds the time dimension. One major difference between xts and most other time series objects in R is the ability to use any one of various classes that are used to represent time. Whether POSIXct, Date, or some other class, xts will convert this into an internal form to make subsetting as natural to the user as possible.

a <- xts(x = 1:2, as.Date("2012-01-01") + 0:1)
a[index(a)]

We'll get into more detail on subsetting xts objects in a later chapter. For now you can simply use date objects to index appropriate rows from your time series. You can think of this as effectively matching the rownames you see in the object. This works as anticipated for time objects because the rownames are really dates!

For this exercise you'll create two time series using two different time classes. You will then subset each object using the other object's index.
```{r}
# Create dates
dates <- as.Date("2016-01-01") + 0:4

# Create ts_a
ts_a <- xts(x = 1:5, order.by = dates)

# Create ts_b
ts_b <- xts(x = 1:5, order.by = as.POSIXct(dates))

# Extract the rows of ts_a using the index of ts_b
ts_a[index(ts_b)]

# Extract the rows of ts_b using the index of ts_a
ts_b[index(ts_a)]

```

The versatile structure of xts objects makes subsetting them very intuitive.

**Importing, exporting and converting time series**
___

___
