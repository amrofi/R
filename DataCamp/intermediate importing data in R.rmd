---
title: "Intermediate Importing Data in R"
author: "DataCamp - Filip Schouwenaars"
date: "12/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(repos="https://CRAN.R-project.org")
```

## R Markdown

**Relational Databases**

- What is a relational database?
- How to connect?
- How to read table?

**Database Management System**

- DBMS
- Open Source
  - MySQL, PostgreSQL, SQLite
- Proprietary
  - Oracle Database, Microsoft SQL Server
- SQL = Structured Query Language

**Databases in R**

- Different R packages
- MySQL: `RMySQL`
- PostgresSQL: `RPostgresSQL`
- Oracle Database: `ROracle`
- Conventions specified in `DBI`
  - interface -> package (implementation)

![](_images/652.png)

**Establish a connection**

The first step to import data from a SQL database is creating a connection to it. As Filip explained, you need different packages depending on the database you want to connect to. All of these packages do this in a uniform way, as specified in the `DBI` package.

[dbConnect()](http://www.rdocumentation.org/packages/DBI/functions/dbConnect) creates a connection between your R session and a SQL database. The first argument has to be a `DBIdriver` object, that specifies how connections are made and how data is mapped between R and the database. Specifically for MySQL databases, you can build such a driver with [RMySQL::MySQL()](http://www.rdocumentation.org/packages/RMySQL/functions/MySQLDriver-class).

If the MySQL database is a remote database hosted on a server, you'll also have to specify the following arguments in [dbConnect()](http://www.rdocumentation.org/packages/DBI/functions/dbConnect): `dbname`, `host`, `port`, `user` and `password`. Most of these details have already been provided.

```{r}
# Load the DBI package
library(DBI)

# Edit dbConnect() call
con <- dbConnect(RMySQL::MySQL(), 
                 dbname = "tweater", 
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com", 
                 port = 3306,
                 user = "student",
                 password = "datacamp")
con
```

Awesome! You are now connected to the MySQL database `tweater`.

## Import table data

![](_images/653.png)

**List the database tables**

After you've successfully connected to a remote MySQL database, the next step is to see what tables the database contains. You can do this with the [dbListTables()](http://www.rdocumentation.org/packages/DBI/functions/dbListTables) function. As you might remember from the video, this function requires the connection object as an input, and outputs a character vector with the table names.

```{r}
# Load the RMySQL package
library(DBI)

# Connect to the MySQL database: con
con <- dbConnect(RMySQL::MySQL(), 
                 dbname = "tweater", 
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com", 
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Build a vector of table names: tables
tables <- dbListTables(con)

# Display structure of tables
str(tables)
```

Good! [dbListTables()](http://www.rdocumentation.org/packages/DBI/functions/dbListTables) can be very useful to get a first idea about the contents of your database. Can you guess what kind of information this database contains?

**Import users**

As you might have guessed by now, the database contains data on a more tasty version of Twitter, namely Tweater. Users can post tweats with short recipes for delicious snacks. People can comment on these tweats. There are three tables: `users`, `tweats`, and `comments` that have relations among them. Which ones, you ask? You'll discover in a moment!

Let's start by importing the data on the users into your R session. You do this with the [dbReadTable()](http://www.rdocumentation.org/packages/DBI/functions/dbReadTable) function. Simply pass it the connection object (`con`), followed by the name of the table you want to import. The resulting object is a standard R data frame.

```{r}
# Load the DBI package
library(DBI)

# Connect to the MySQL database: con
con <- dbConnect(RMySQL::MySQL(), 
                 dbname = "tweater", 
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com", 
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Import the users table from tweater: users
users <- dbReadTable(con, "users")

# Print users
users
```

**Import all tables**

Next to the `users`, we're also interested in the `tweats` and `comments` tables. However, separate `dbReadTable()` calls for each and every one of the tables in your database would mean a lot of code duplication. Remember about the `lapply()` function? You can use it again here! A connection is already coded for you, as well as a vector `table_names`, containing the names of all the tables in the database.

```{r}
# Load the DBI package
library(DBI)

# Connect to the MySQL database: con
con <- dbConnect(RMySQL::MySQL(), 
                 dbname = "tweater", 
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com", 
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Get table names
table_names <- dbListTables(con)

# Import all tables
tables <- lapply(table_names, dbReadTable, conn = con)

# Print out tables
tables
```

Wonderful! Now that you have an R version of all data that is contained in the database, you can dive a little deeper into the relations between the different data frames.

## SQL Queries from inside R

**Selective importing**

- SQL Queries
- DBI -> RMySQL, RPostgreSQL
- Just the basics of SQL

![](_images/654.png)

![](_images/655.png)

![](_images/656.png)

**Query tweater (1)**

In your life as a data scientist, you'll often be working with huge databases that contain tables with millions of rows. If you want to do some analyses on this data, it's possible that you only need a fraction of this data. In this case, it's a good idea to send SQL queries to your database, and only import the data you actually need into R.

[dbGetQuery()](http://www.rdocumentation.org/packages/DBI/functions/dbGetQuery) is what you need. As usual, you first pass the connection object to it. The second argument is an SQL query in the form of a character string. This example selects the `age` variable from the `people` dataset where gender equals `"male"`:

```
dbGetQuery(con, "SELECT age FROM people WHERE gender = 'male'")
```

A connection to the `tweater` database has already been coded for you.

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Import tweat_id column of comments where user_id is 1: elisabeth
elisabeth <- dbGetQuery(con, "SELECT tweat_id FROM comments WHERE user_id = 1")

# Print  elisabeth
elisabeth
```

Nice! To make sure you understood SQL's `SELECT` - `FROM` - `WHERE` syntax, let's practice some more.

**Query tweater (2)**

Apart from checking equality, you can also check for *less than* and *greater than* relationships, with `<` and `>`, just like in R.

`con`, a connection to the `tweater` database, is again available.

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Import post column of tweats where date is higher than '2015-09-21': latest
latest <- dbGetQuery(con, "SELECT post FROM tweats WHERE date > '2015-09-21'")

# Print latest
latest
```

Nice! To make sure you understood SQL's `SELECT` - `FROM` - `WHERE` syntax, let's practice some more.

**Query tweater (3)**

Suppose that you have a `people` table, with a bunch of information. This time, you want to find out the `age` and `country` of married males. Provided that there is a `married` column that's 1 when the person in question is married, the following query would work.

```
SELECT age, country
  FROM people
    WHERE gender = "male" AND married = 1
```

Can you use a similar approach for a more specialized query on the `tweater` database?

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Create data frame specific
specific <- dbGetQuery(con, "SELECT message FROM comments WHERE tweat_id = 77 AND user_id > 4")

# Print specific and short
specific
```

**Query tweater (4)**

There are also dedicated SQL functions that you can use in the `WHERE` clause of an SQL query. For example, `CHAR_LENGTH()` returns the number of characters in a string.

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Create data frame short
short <- dbGetQuery(con, "SELECT id, name FROM users WHERE CHAR_LENGTH(name) < 5")

# Print short
short
```

**Join the query madness!**

Of course, SQL does not stop with the the three keywords `SELECT`, `FROM` and `WHERE`. Another very often used keyword is `JOIN`, and more specifically `INNER JOIN`. Take this call for example:

```
SELECT name, post
  FROM users INNER JOIN tweats on users.id = user_id
    WHERE date > "2015-09-19"
```

Here, the `users` table is joined with the `tweats` table. This is possible because the `id` column in the `users` table corresponds to the `user_id` column in the `tweats` table. Also notice how `name`, from the `users` table, and `post` and `date`, from the `tweats` table, can be referenced to without problems.

Can you predict the outcome of the following query?

```
SELECT post, message
  FROM tweats INNER JOIN comments on tweats.id = tweat_id
    WHERE tweat_id = 77
```

A connection to the `tweater` database is already available as `con`; feel free to experiment!

```{r}
dbGetQuery(con, "SELECT post, message
                 FROM tweats INNER JOIN comments on tweats.id = tweat_id
                 WHERE tweat_id = 77")
```

Bellissimo! Have you tried running this query with [dbGetQuery()](http://www.rdocumentation.org/packages/DBI/functions/dbGetQuery)? The result contains data both from the `tweats` and the `comments` column.

## DBI internals

![](_images/657.png)

![](_images/658.png)

![](_images/659.png)

**Send - Fetch - Clear**

You've used [dbGetQuery()](http://www.rdocumentation.org/packages/DBI/functions/dbGetQuery) multiple times now. This is a virtual function from the `DBI` package, but is actually implemented by the `RMySQL` package. Behind the scenes, the following steps are performed:

- Sending the specified query with [dbSendQuery()](http://www.rdocumentation.org/packages/DBI/functions/dbSendQuery);
- Fetching the result of executing the query on the database with [dbFetch()](http://www.rdocumentation.org/packages/DBI/functions/dbFetch);
- Clearing the result with [dbClearResult()](http://www.rdocumentation.org/packages/DBI/functions/dbClearResult).

Let's not use [dbGetQuery()](http://www.rdocumentation.org/packages/DBI/functions/dbGetQuery) this time and implement the steps above. This is tedious to write, but it gives you the ability to fetch the query's result in chunks rather than all at once. You can do this by specifying the `n` argument inside [dbFetch()](http://www.rdocumentation.org/packages/DBI/functions/dbFetch).

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Send query to the database
res <- dbSendQuery(con, "SELECT * FROM comments WHERE user_id > 4")

# Use dbFetch() twice
dbFetch(res, n = 2)
dbFetch(res)

# Clear res
dbClearResult(res)
```

Perfect! In our toy example, chopping up the fetches doesn't make a lot of sense, but make sure to remember this technique when you're struggling with huge databases!

**Be polite and ...**

Every time you connect to a database using [dbConnect()](http://www.rdocumentation.org/packages/DBI/functions/dbConnect), you're creating a new connection to the database you're referencing. `RMySQL` automatically specifies a maximum of open connections and closes some of the connections for you, but still: it's always polite to manually disconnect from the database afterwards. You do this with the [dbDisconnect()](http://www.rdocumentation.org/packages/DBI/functions/dbDisconnect) function.

The code that connects you to the database is already available, can you finish the script?

```{r}
# Connect to the database
library(DBI)
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "tweater",
                 host = "courses.csrrinzqubik.us-east-1.rds.amazonaws.com",
                 port = 3306,
                 user = "student",
                 password = "datacamp")

# Create the data frame  long_tweats
long_tweats <- dbGetQuery(con, "SELECT post, date FROM tweats WHERE CHAR_LENGTH(post) > 40")

# Print long_tweats
long_tweats

# Disconnect from the database
dbDisconnect(con)
```

Wonderful! This concludes the chapter on databases. Of course, there is tons more to learn about interfacing to databases and working with them as efficiently as possible, but that's something for more advanced courses.

## HTTP

**Data on the web**

- already worked on it!
- many packages handle it for you
- file formats useful for web technology
- JSON

![](_images/660.png)

**Import flat files from the web**

In the video, you saw that the `utils` functions to import flat file data, such as [read.csv()](http://www.rdocumentation.org/packages/utils/functions/read.table) and [read.delim()](http://www.rdocumentation.org/packages/utils/functions/read.table), are capable of automatically importing from URLs that point to flat files on the web.

You must be wondering whether Hadley Wickham's alternative package, `readr`, is equally potent. Well, figure it out in this exercise! The URLs for both a `.csv` file as well as a `.delim` file are already coded for you. It's up to you to actually import the data. If it works, that is…

```{r}
# Load the readr package
library(readr)

# Import the csv file: pools
url_csv <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/swimming_pools.csv"
pools <- read_csv(url_csv)

# Import the txt file: potatoes
url_delim <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/potatoes.txt"
potatoes <- read_tsv(url_delim)

# Print pools and potatoes
pools
potatoes
```

Great! It seems to work without any additional problems!

**Secure importing**

In the previous exercises, you have been working with URLs that all start with `http://`. There is, however, a safer alternative to HTTP, namely HTTPS, which stands for HypterText Transfer Protocol Secure. Just remember this: HTTPS is relatively safe, HTTP is not.

Luckily for us, you can use the standard importing functions with `https://` connections since R version 3.2.2.

```{r}
# https URL to the swimming_pools csv file.
url_csv <- "https://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/swimming_pools.csv"

# Import the file using read.csv(): pools1
pools1 <- read.csv(url_csv)

# Load the readr package
library(readr)

# Import the file using read_csv(): pools2
pools2 <- read_csv(url_csv)

# Print the structure of pools1 and pools2
str(pools1)
str(pools2)
```

Great! It seems to work without any additional problems!

## Downloading files

![](_images/661.png)

**Why download.file()?**

- Reproducibility

- HTTP from inside R
  - authentication
  - additional parameters
  - `httr` - Hadley Wickham

**Import Excel files from the web**

When you learned about `gdata`, it was already mentioned that `gdata` can handle `.xls` files that are on the internet. `readxl` can't, at least not yet. The URL with which you'll be working is already available in the sample code. You will import it once using `gdata` and once with the `readxl` package via a workaround.

```{r}
# Load the readxl and gdata package
library(readxl)
library(gdata)

# Specification of url: url_xls
url_xls <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/latitude.xls"

# Import the .xls file with gdata: excel_gdata
excel_gdata <- read.xls(url_xls)

# Download file behind URL, name it local_latitude.xls
download.file(url_xls, destfile = "_data/local_latitude.xls", quiet = TRUE, mode = "wb")

# Import the local .xls file with readxl: excel_readxl
excel_readxl <- read_excel("_data/local_latitude.xls")
```

Nice! It appears that `readxl` is not (yet?) able to deal with Excel files that are on the web. However, a simply workaround with [download.file()](http://www.rdocumentation.org/packages/utils/functions/download.file) fixes this.

**Downloading any file, secure or not**

In the previous exercise you've seen how you can read excel files on the web using the `read_excel` package by first downloading the file with the [download.file()](http://www.rdocumentation.org/packages/utils/functions/download.file) function.

There's more: with [download.file()](http://www.rdocumentation.org/packages/utils/functions/download.file) you can download any kind of file from the web, using HTTP and HTTPS: images, executable files, but also `.RData` files. An `RData` file is very efficient format to store R data.

You can load data from an `RData` file using the [load()](http://www.rdocumentation.org/packages/base/functions/load) function, but this function does not accept a URL string as an argument. In this exercise, you'll first download the RData file securely, and then import the local data file.

```{r}
# https URL to the wine RData file.
url_rdata <- "https://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/wine.RData"

# Download the wine file to your working directory
download.file(url_rdata, destfile = "_data/wine_local.RData")

# Load the wine data into your workspace using load()
load("_data/wine_local.RData")

# Print out the summary of the wine data
summary(wine)
```

Great! Another way to load remote `RData` files is to use the [url()](http://www.rdocumentation.org/packages/base/functions/connections) function inside [load()](http://www.rdocumentation.org/packages/base/functions/load). However, this will not save the `RData` file to a local file.

**HTTP? httr! (1)**

Downloading a file from the Internet means sending a GET request and receiving the file you asked for. Internally, all the previously discussed functions use a GET request to download files.

`httr` provides a convenient function, [GET()](http://www.rdocumentation.org/packages/httr/functions/GET) to execute this GET request. The result is a `response` object, that provides easy access to the status code, content-type and, of course, the actual content.

You can extract the [content](http://www.rdocumentation.org/packages/httr/functions/content) from the request using the content() function. At the time of writing, there are three ways to retrieve this content: as a raw object, as a character vector, or an R object, such as a list. If you don't tell [content()](http://www.rdocumentation.org/packages/httr/functions/content) how to retrieve the content through the `as` argument, it'll try its best to figure out which type is most appropriate based on the content-type.

```{r}
# Load the httr package
library(httr)

# Get the url, save response to resp
url <- "http://www.example.com/"
resp <- GET(url)

# Print resp
resp

# Get the raw content of resp: raw_content
raw_content <- content(resp, as = "raw")

# Print the head of raw_content
head(raw_content)
```

Great! The raw content of the response doesn't make a lot of sense, does it? Luckily, the [content()](http://www.rdocumentation.org/packages/httr/functions/content) function by default, if you don't specify the `as` argument, figures out what type of data you're dealing with and parses it for you.

**HTTP? httr! (2)**

Web content does not limit itself to HTML pages and files stored on remote servers such as DataCamp's Amazon S3 instances. There are many other data formats out there. A very common one is JSON. This format is very often used by so-called Web APIs, interfaces to web servers with which you as a client can communicate to get or store information in more complicated ways.

You'll learn about Web APIs and JSON in the video and exercises that follow, but some experimentation never hurts, does it?

```{r}
# httr is already loaded

# Get the url
url <- "http://www.omdbapi.com/?apikey=72bc447a&t=Annie+Hall&y=&plot=short&r=json"
resp <- GET(url)

# Print resp
resp

# Print content of resp as text
content(resp, as = "text")

# Print content of resp
content(resp)
```

Great! The fact that `httr` converts the JSON response body automatically to an R list is very convenient.

## APIs & JSON

**Other data formats**

- before: pages and files from the web
- JSON
- simple, concise, well-structured
- human readable
- easy to parse amd generate for computers
- for communication with web APIs

**API**

- Application Programming Interface
- set of routines and protocols for building software
- how different components interact
- web API
  - interface to get or add data to a server

**jsonlite**

- Jeroen Ooms
- improvement of earlier packages
- consistent, robust
- support all use cases

**From JSON to R**

In the simplest setting, [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) can convert character strings that represent JSON data into a nicely structured R list. Give it a try!

```{r}
# Load the jsonlite package
library(jsonlite)

# wine_json is a JSON
wine_json <- '{"name":"Chateau Migraine", "year":1997, "alcohol_pct":12.4, "color":"red", "awarded":false}'

# Convert wine_json into a list: wine
wine <- fromJSON(wine_json)

# Print structure of wine
str(wine)
```

**Quandl API**

As Filip showed in the video, [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) also works if you pass a URL as a character string or the path to a local file that contains JSON data. Let's try this out on the Quandl API, where you can fetch all sorts of financial and economical data.

```{r}
# jsonlite is preloaded

# Definition of quandl_url
quandl_url <- "https://www.quandl.com/api/v3/datasets/WIKI/FB/data.json?auth_token=i83asDsiWUUyfoypkgMz"

# Import Quandl data: quandl_data
quandl_data <- fromJSON(quandl_url)

# Print structure of quandl_data
str(quandl_data)
```

Great! You successfully imported JSON data directly from the web. If you have a close look at the structure of `quandl_data`, you'll see that the `data` element is a matrix.

**OMDb API**

In the video, you saw how easy it is to interact with an API once you know how to formulate requests. You also saw how to fetch all information on Rain Man from OMDb. Simply perform a [GET()](http://www.rdocumentation.org/packages/httr/functions/GET) call, and next ask for the contents with the [content()](http://www.rdocumentation.org/packages/httr/functions/content) function. This [content()](http://www.rdocumentation.org/packages/httr/functions/content) function, which is part of the `httr` package, uses `jsonlite` behind the scenes to import the JSON data into R.

However, by now you also know that `jsonlite` can handle URLs itself. Simply passing the request URL to [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) will get your data into R. In this exercise, you will be using this technique to compare the release year of two movies in the Open Movie Database.

```{r}
# The package jsonlite is already loaded

# Definition of the URLs
url_sw4 <- "http://www.omdbapi.com/?apikey=72bc447a&i=tt0076759&r=json"
url_sw3 <- "http://www.omdbapi.com/?apikey=72bc447a&i=tt0121766&r=json"

# Import two URLs with fromJSON(): sw4 and sw3
sw4 <- fromJSON(url_sw4)
sw3 <- fromJSON(url_sw3)

# Print out the Title element of both lists
sw4$Title
sw3$Title

# Is the release year of sw4 later than sw3?
sw4$Year > sw3$Year
```

Well done! The fourth episode of the Star Wars saga was released before the third one! Enough of the [fromJSON()]() now. Let's try to convert some R data into JSON format now.

## JSON & jsonlite

![](_images/662.png)

![](_images/663.png)

![](_images/664.png)

![](_images/665.png)

**Other jsonlite functions**

- `toJSON()`
- `prettify()`
- `minify()`

**JSON practice (1)**
JSON is built on two structures: objects and arrays. To help you experiment with these, two JSON strings are included in the sample code. It's up to you to change them appropriately and then call `jsonlite`'s [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) function on them each time.

```{r}
# jsonlite is already loaded

# Challenge 1
json1 <- '[1, 2, 3, 4, 5, 6]'
fromJSON(json1)

# Challenge 2
json2 <- '{"a": [1, 2, 3], "b": [4, 5, 6]}'
fromJSON(json2)
```

**JSON practice (2)**

We prepared two more JSON strings in the sample code. Can you change them and call `jsonlite`'s [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) function on them, similar to the previous exercise?

```{r}
# jsonlite is already loaded

# Challenge 1
json1 <- '[[1, 2], [3, 4]]'
fromJSON(json1)

# Challenge 2
json2 <- '[{"a": 1, "b": 2}, {"a": 3, "b": 4}, {"a": 5, "b": 6}]'
fromJSON(json2)
```

Great! As you can see different JSON data structures will lead to different data structures in `R`.

**toJSON()**

Apart from converting JSON to R with [fromJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON), you can also use [toJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) to convert R data to a JSON format. In its most basic use, you simply pass this function an R object to convert to a JSON. The result is an R object of the class `json`, which is basically a character string representing that JSON.

For this exercise, you will be working with a `.csv` file containing information on the amount of desalinated water that is produced around the world. As you'll see, it contains a lot of missing values. This data can be found on the URL that is specified in the sample code.

```{r}
# jsonlite is already loaded

# URL pointing to the .csv file
url_csv <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/water.csv"

# Import the .csv file located at url_csv
water <- read.csv(url_csv, stringsAsFactors = FALSE)

# Convert the data file according to the requirements
water_json <- toJSON(water)

# Print out water_json
water_json
```

Congratulations! As you can see, the JSON you printed out isn't easy to read. In the next exercise, you will print out some more JSONs, and explore ways to prettify or minify the output.

**Minify and prettify**

JSONs can come in different formats. Take these two JSONs, that are in fact exactly the same: the first one is in a minified format, the second one is in a pretty format with indentation, whitespace and new lines:

```
# Mini
{"a":1,"b":2,"c":{"x":5,"y":6}}

# Pretty
{
  "a": 1,
  "b": 2,
  "c": {
    "x": 5,
    "y": 6
  }
}
```

Unless you're a computer, you surely prefer the second version. However, the standard form that [toJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) returns, is the minified version, as it is more concise. You can adapt this behavior by setting the `pretty` argument inside [toJSON()](http://www.rdocumentation.org/packages/jsonlite/functions/fromJSON) to `TRUE`. If you already have a JSON string, you can use [prettify()](http://www.rdocumentation.org/packages/jsonlite/functions/prettify) or [minify()](http://www.rdocumentation.org/packages/jsonlite/functions/prettify) to make the JSON pretty or as concise as possible.

```{r}
# jsonlite is already loaded

# Convert mtcars to a pretty JSON: pretty_json
pretty_json <- toJSON(mtcars, pretty = TRUE)

# Print pretty_json
#pretty_json

# Minify pretty_json: mini_json
mini_json <- minify(pretty_json)

# Print mini_json
mini_json
```

Great! Hopefully you agree that the pretty format is way easier to read and understand than the minified format! This exercise concludes the course on importing data!

## haven

![](_images/666.png)

**R packages to import data**

- haven
  - Hadley Wickham
  - goal: consistent, easy, fast
  
- foreign
  - R core team
  - support for many data formats
  
**haven**

- SAS, STATA, and SPSS
- ReadStat: C library by Evan Miller
- extremely simple to use
- single argument: path to file
- result: R data frame

![](_images/667.png)

![](_images/668.png)

**Import SAS data with haven**

`haven` is an extremely easy-to-use package to import data from three software packages: SAS, STATA and SPSS. Depending on the software, you use different functions:

- SAS: `read_sas()`
- STATA: `read_dta()` (or `read_stata()`, which are identical)
- SPSS: `read_sav()` or `read_por()`, depending on the file type.

All these functions take one key argument: the path to your local file. In fact, you can even pass a URL; `haven` will then automatically download the file for you before importing it.

You'll be working with data on the age, gender, income, and purchase level (0 = low, 1 = high) of 36 individuals (Source: [SAS](http://support.sas.com/learn/)). The information is stored in a SAS file, `sales.sas7bdat`, which is available in your current working directory. You can also download the data [here](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/sales.sas7bdat).

```{r}
# Load the haven package
library(haven)

# Import sales.sas7bdat: sales
sales <- read_sas("_data/sales.sas7bdat")

# Display the structure of sales
str(sales)
```

Congratulations! As you can see, [read_sas()](http://cran.r-project.org/web/packages/haven/haven.pdf) enables you to import SAS data files easily.

**Import STATA data with haven**

Next up are STATA data files; you can use [read_dta()](http://cran.r-project.org/web/packages/haven/haven.pdf) for these.

When inspecting the result of the `read_dta()` call, you will notice that one column will be imported as a `labelled` vector, an R equivalent for the common data structure in other statistical environments. In order to effectively continue working on the data in R, it's best to change this data into a standard R class. To convert a variable of the class `labelled` to a factor, you'll need `haven`'s [as_factor()](http://cran.r-project.org/web/packages/haven/haven.pdf) function.

In this exercise, you will work with data on yearly import and export numbers of sugar, both in USD and in weight. The data can be found [here](http://assets.datacamp.com/production/course_1478/datasets/trade.dta)

```{r}
# haven is already loaded

# Import the data from the URL: sugar
sugar <- read_dta("http://assets.datacamp.com/production/course_1478/datasets/trade.dta")

# Structure of sugar
str(sugar)

# Convert values in Date column to dates
sugar$Date <- as.Date(as_factor(sugar$Date))

# Structure of sugar again
str(sugar)
```

**Import SPSS data with haven**

The `haven` package can also import data files from SPSS. Again, importing the data is pretty straightforward. Depending on the SPSS data file you're working with, you'll need either [read_sav()](http://cran.r-project.org/web/packages/haven/haven.pdf) - for `.sav` files - or [read_por()](http://cran.r-project.org/web/packages/haven/haven.pdf) - for `.por` files.

In this exercise, you will work with data on four of the Big Five personality traits for 434 persons (Source: [University of Bath](http://staff.bath.ac.uk/pssiw/stats2/page16/page16.html)). The Big Five is a psychological concept including, originally, five dimensions of personality to classify human personality. The SPSS dataset is called [person.sav](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/person.sav) and is available in your working directory.

```{r}
# haven is already loaded

# Import person.sav: traits
traits <- read_sav("_data/person.sav")

# Summarize traits
summary(traits)

# Print out a subset
subset(traits, Extroversion > 40 & Agreeableness > 40)
```

Great! You imported a data file from SPSS correctly using `read_sav()`. Deepen your knowledge in the following exercise!

**Factorize, round two**

In the last exercise you learned how to import a data file using the command [read_sav()](http://cran.r-project.org/web/packages/haven/haven.pdf). With SPSS data files, it can also happen that some of the variables you import have the `labelled` class. This is done to keep all the labelling information that was originally present in the `.sav` and `.por` files. It's advised to coerce (or change) these variables to factors or other standard R classes.

The data for this exercise involves information on employees and their demographic and economic attributes (Source: [QRiE](http://cehd.gmu.edu/book/dimitrov/spss)). The data can be found [here](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/employee.sav)

```{r}
# haven is already loaded

# Import SPSS data from the URL: work
work <- read_sav("http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/employee.sav")

# Display summary of work$GENDER
summary(work$GENDER)

# Convert work$GENDER to a factor
work$GENDER <- as_factor(work$GENDER)

# Display summary of work$GENDER again
summary(work$GENDER)
```

Well done! The [as_factor()](http://cran.r-project.org/web/packages/haven/haven.pdf) function has more arguments you can specify, have a look at its documentation to discover more! Proceed to the next video.

## foreign

- R core team
- less consistent
- very comprehensive
- all kinds of foreign data formats
- SAS, STATA, SPSS, Systat, Weka ...

**SAS**

- cannot import `.sas7bdat`
- only SAS libraries: `.xport`
- `sas7bdat` package

**STATA**

- STATA 5 to 12
- `read.dta()`

![](_images/669.png)

**SPSS**

- `read.spss()`

![](_images/670.png)

**Import STATA data with foreign (1)**

The `foreign` package offers a simple function to import and read *STATA* data: [read.dta()](http://www.rdocumentation.org/packages/foreign/functions/read.dta).

In this exercise, you will import data on the US presidential elections in the year 2000. The data in `florida.dta` contains the total numbers of votes for each of the four candidates as well as the total number of votes per election area in the state of Florida (Source: [Florida Department of State](http://results.elections.myflorida.com/)). The file is available in your working directory, you can download it [here](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/florida.dta) if you want to experiment some more.

```{r}
# Load the foreign package
library(foreign)

# Import florida.dta and name the resulting data frame florida
florida <- read.dta("_data/florida.dta")

# Check tail() of florida
tail(florida)
```

Congratulations! Your first exercise on using `foreign` to import STATA data is complete. Proceed to the next exercise to learn the proper handling of the arguments that [read.dta()](http://www.rdocumentation.org/packages/foreign/functions/read.dta) includes!

**Import STATA data with foreign (2)**

Data can be very diverse, going from character vectors to categorical variables, dates and more. It's in these cases that the additional arguments of [read.dta()](http://www.rdocumentation.org/packages/foreign/functions/read.dta) will come in handy.

The arguments you will use most often are `convert.dates`, `convert.factors`, `missing.type` and `convert.underscore`. Their meaning is pretty straightforward, as Filip explained in the video. It's all about correctly converting STATA data to standard R data structures. Type `?read.dta` to find out about about the default values.

The dataset for this exercise contains socio-economic measures and access to education for different individuals (Source: [World Bank](http://datatopics.worldbank.org/Gender/topic/education)). This data is available as [edequality.dta](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/edequality.dta), which is located in the `_data` folder in your working directory.

```{r}
# foreign is already loaded

# Specify the file path using file.path(): path
path <- file.path("_data", "edequality.dta")

# Create and print structure of edu_equal_1
edu_equal_1 <- read.dta(path)
str(edu_equal_1)

# Create and print structure of edu_equal_2
edu_equal_2 <- read.dta(path, convert.factors = FALSE)
str(edu_equal_2)

# Create and print structure of edu_equal_3
edu_equal_3 <- read.dta(path, convert.underscore = TRUE)
str(edu_equal_3)
```

Great! Can you tell the difference between the different versions of [read.dta()](http://www.rdocumentation.org/packages/foreign/functions/read.dta)? For this data, the first version (where you simply specified the file path) will be most useful to work with. Head over to the next exercise to see if you actually understand your data!

**Import SPSS data with foreign (1)**

All great things come in pairs. Where `foreign` provided [read.dta()](http://www.rdocumentation.org/packages/foreign/functions/read.dta) to read Stata data, there's also [read.spss()](http://www.rdocumentation.org/packages/foreign/functions/read.spss) to read SPSS data files. To get a data frame, make sure to set `to.data.frame = TRUE` inside [read.spss()](http://www.rdocumentation.org/packages/foreign/functions/read.spss).

In this exercise, you'll be working with socio-economic variables from different countries (Source: [Quantative Data Analysis in Education](http://cw.routledge.com/textbooks/9780415372985/resources/datasets.asp)). The SPSS data is in a file called `international.sav`, which is in your working directory. You can also download it [here](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/international.sav) if you want to play around with it some more.

```{r}
# foreign is already loaded

# Import international.sav as a data frame: demo
demo <- read.spss("_data/international.sav", to.data.frame = TRUE)

# Create boxplot of gdp variable of demo
boxplot(demo$gdp)
```

**Import SPSS data with foreign (2)**

In the previous exercise, you used the `to.data.frame` argument inside [read.spss()](http://www.rdocumentation.org/packages/foreign/functions/read.spss). There are many other ways in which to customize the way your SPSS data is imported.

In this exercise you will experiment with another argument, `use.value.labels`. It specifies whether variables with value labels should be converted into R factors with levels that are named accordingly. The argument is `TRUE` by default which means that so called labelled variables inside SPSS are converted to factors inside R.

You'll again be working with the [international.sav](http://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/international.sav) data, which is available in your current working directory.

```{r}
# foreign is already loaded

# Import international.sav as demo_1
demo_1 <- read.spss("_data/international.sav", to.data.frame = TRUE)

# Print out the head of demo_1
head(demo_1)

# Import international.sav as demo_2
demo_2 <- read.spss("_data/international.sav", to.data.frame = TRUE, use.value.labels = FALSE)

# Print out the head of demo_2
head(demo_2)
```

Congratulations on finishing part 2 of Importing Data in R! See you next time!