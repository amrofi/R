ggplot(evals, aes(x = bty_avg)) +
geom_histogram(binwidth = 0.5) +
labs(x = "Beauty score", y = "count")
# Plot the histogram
ggplot(evals, aes(x = bty_avg)) +
geom_histogram(binwidth = 0.5) +
labs(x = "Beauty score", y = "count")
# Scatterplot
ggplot(evals, aes(x = bty_avg, y = score)) +
geom_point() +
labs(x = "beauty score", y = "teaching score")
# Jitter plot
ggplot(evals, aes(x = bty_avg, y = score)) +
geom_jitter() +
labs(x = "beauty score", y = "teaching score")
# Compute correlation
evals %>%
summarize(correlation = cor(score, bty_avg))
# View the structure of log10_price and waterfront
house_prices %>%
select(log10_price, waterfront) %>%
glimpse()
house_prices <- house_prices_2
# View the structure of log10_price and waterfront
house_prices %>%
select(log10_price, waterfront) %>%
glimpse()
house_prices_2 <- house_prices %>%
mutate(log10_price = log10(price))
house_prices <- house_prices_2
# View the structure of log10_price and waterfront
house_prices %>%
select(log10_price, waterfront) %>%
glimpse()
# Plot
ggplot(house_prices, aes(x = waterfront, y = log10_price)) +
geom_boxplot() +
labs(x = "waterfront", y = "log10 price")
# Calculate stats
house_prices %>%
group_by(waterfront) %>%
summarize(mean_log10_price = mean(log10_price), n = n())
# Prediction of price for houses with view
10^(6.12)
# Prediction of price for houses without view
10^(5.66)
# Calculate stats
house_prices %>%
group_by(waterfront) %>%
summarize(mean_log10_price = mean(log10_price), n = n())
# Prediction of price for houses with view
10^(6.12)
# Prediction of price for houses without view
10^(5.66)
# Load packages
library(ggplot2)
library(dplyr)
library(moderndive)
# Plot
ggplot(evals, aes(x = bty_avg, y = score)) +
geom_point() +
labs(x = "beauty score", y = "score") +
geom_smooth(method = "lm", se = FALSE)
# Load package
library(moderndive)
# Fit model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Output content
model_score_2
# Output regression table
get_regression_table(model_score_2)
str(model_score_2)
get_regression_table
lhs
# Load package
library(moderndive)
# Fit model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Output content
model_score_2
# Output regression table
get_regression_table(model_score_2, print = TRUE)
?lhs
lhs
lhs()
# Load package
library(moderndive)
# Fit model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Output content
model_score_2
# Output regression table
get_regression_table(model_score_2, print = TRUE)
# Use fitted intercept and slope to get a prediction
y_hat <- 3.88 + 5 * 0.0670
y_hat
# Use fitted intercept and slope to get a prediction
y_hat <- 3.88 + 5 * 0.0670
y_hat
# Compute residual y - y_hat
4.7 - 4.215
# Fit regression model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Get regression table
get_regression_table(model_score_2)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2)
# Fit regression model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Get regression table
get_regression_table(model_score_2)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2) %>%
mutate(score_hat_2 = 3.88 + 0.067 * bty_avg)
# Fit regression model
model_score_2 <- lm(score ~ bty_avg, data = evals)
# Get regression table
get_regression_table(model_score_2)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2) %>%
mutate(score_hat_2 = 3.88 + 0.067 * bty_avg)
# Get all fitted/predicted values and residuals
get_regression_points(model_score_2) %>%
mutate(residual_2 = score - score_hat)
ggplot(evals, aes(x = rank, y = score)) +
geom_boxplot() +
labs(x = "rank", y = "score")
ggplot(evals, aes(x = rank, y = score)) +
geom_boxplot() +
labs(x = "rank", y = "score")
evals %>%
group_by(rank) %>%
summarize(n = n(), mean_score = mean(score), sd_score = sd(score))
# Calculate predictions and residuals
model_score_4_points <- get_regression_points(model_score_4)
# Fit regression model
model_score_4 <- lm(score ~ rank, data = evals)
# Get regression table
get_regression_table(model_score_4)
# teaching mean
teaching_mean <- 4.28
# tenure track mean
tenure_track_mean <- 4.28 - 0.13
# tenured mean
tenured_mean <- 4.28 - 0.145
# Calculate predictions and residuals
model_score_4_points <- get_regression_points(model_score_4)
model_score_4_points
# Plot residuals
ggplot(model_score_4_points, aes(x = residual)) +
geom_histogram() +
labs(x = "residuals", title = "Residuals from score ~ rank model")
# Create scatterplot with regression line
ggplot(house_prices, aes(x = bedrooms, y = log10_price)) +
geom_point() +
labs(x = "Number of bedrooms", y = "log10 price") +
geom_smooth(method = "lm", se = FALSE)
# Create scatterplot with regression line
ggplot(house_prices, aes(x = bedrooms, y = log10_price)) +
geom_point() +
labs(x = "Number of bedrooms", y = "log10 price") +
geom_smooth(method = "lm", se = FALSE)
# Remove outlier
house_prices_transform <- house_prices %>%
filter(bedrooms < 20)
# Create scatterplot with regression line
ggplot(house_prices_transform, aes(x = bedrooms, y = log10_price)) +
geom_point() +
labs(x = "Number of bedrooms", y = "log10 price") +
geom_smooth(method = "lm", se = FALSE)
# Fit model
model_price_2 <- lm(log10_price ~ log10_size + bedrooms,
data = house_prices)
# Get regression table
get_regression_table(model_price_2)
# Make prediction in log10 dollars
2.69 + 0.941 * log10(1000) - .033 * 3
# Make prediction dollars
10^5.414
# Automate prediction and residual computation
get_regression_points(model_price_2)
# Fit model
model_price_4 <- lm(log10_price ~ log10_size + waterfront,
data = house_prices)
# Get regression table
get_regression_table(model_price_4)
# Get regression table
get_regression_table(model_price_4)
# Prediction for House A
10^(2.96 + 0.825 * 2.9 + 0.322)
# Prediction for House B
10^(2.96 + 0.825 * 3.1)
new_houses_2 <- data_frame(log10_size = c(2.9, 3.1), waterfront = c(TRUE, FALSE))
new_houses_2 <- tibble(log10_size = c(2.9, 3.1), waterfront = c(TRUE, FALSE))
new_houses_2 <- tibble(log10_size = c(2.9, 3.1), waterfront = c(TRUE, FALSE))
# View the "new" houses
new_houses_2
# Get predictions on "new" houses
get_regression_points(model_price_4, newdata = new_houses_2)
new_houses_2 <- tibble(log10_size = c(2.9, 3.1), waterfront = c(TRUE, FALSE))
# View the "new" houses
new_houses_2
# Get predictions on "new" houses
get_regression_points(model_price_4, newdata = new_houses_2)
# Get predictions price_hat in dollars on "new" houses
get_regression_points(model_price_4, newdata = new_houses_2) %>%
mutate(price_hat = 10^log10_price_hat)
# Model 2
model_price_2 <- lm(log10_price ~ log10_size + bedrooms,
data = house_prices)
# Calculate squared residuals
get_regression_points(model_price_2) %>%
mutate(sq_residuals = residual^2) %>%
summarize(sum_sq_residuals = sum(sq_residuals))
# Model 4
model_price_4 <- lm(log10_price ~ log10_size + waterfront,
data = house_prices)
# Calculate squared residuals
get_regression_points(model_price_4) %>%
mutate(sq_residuals = residual^2) %>%
summarize(sum_sq_residuals = sum(sq_residuals))
# Fit model
model_price_2 <- lm(log10_price ~ log10_size + bedrooms,
data = house_prices)
# Get fitted/values & residuals, compute R^2 using residuals
get_regression_points(model_price_2) %>%
summarize(r_squared = 1 - var(residual) / var(log10_price))
# Fit model
model_price_4 <- lm(log10_price ~ log10_size + waterfront,
data = house_prices)
# Get fitted/values & residuals, compute R^2 using residuals
get_regression_points(model_price_4) %>%
summarize(r_squared = 1 - var(residual) / var(log10_price))
# Get all residuals, square them, and take mean
get_regression_points(model_price_2) %>%
mutate(sq_residuals = residual^2) %>%
summarize(mse = mean(sq_residuals))
# Get all residuals, square them, take the mean and square root
get_regression_points(model_price_2) %>%
mutate(sq_residuals = residual^2) %>%
summarize(mse = mean(sq_residuals)) %>%
mutate(rmse = sqrt(mse))
# MSE and RMSE for model_price_2
get_regression_points(model_price_2) %>%
mutate(sq_residuals = residual^2) %>%
summarize(mse = mean(sq_residuals), rmse = sqrt(mean(sq_residuals)))
# MSE and RMSE for model_price_4
get_regression_points(model_price_4) %>%
mutate(sq_residuals = residual^2) %>%
summarize(mse = mean(sq_residuals), rmse = sqrt(mean(sq_residuals)))
# Set random number generator seed value for reproducibility
set.seed(76)
# Randomly reorder the rows
house_prices_shuffled <- house_prices %>%
sample_frac(size = 1, replace = FALSE)
# Train/test split
train <- house_prices_shuffled %>%
slice(1:10000)
test <- house_prices_shuffled %>%
slice(10001:21613)
# Set random number generator seed value for reproducibility
set.seed(76)
# Randomly reorder the rows
house_prices_shuffled <- house_prices %>%
sample_frac(size = 1, replace = FALSE)
# Train/test split
train <- house_prices_shuffled %>%
slice(1:10000)
test <- house_prices_shuffled %>%
slice(10001:21613)
# Fit model to training set
train_model_2 <- lm(log10_price ~ log10_size + bedrooms, data = train)
# Make predictions on test set
get_regression_points(train_model_2, newdata = test)
# Compute RMSE
get_regression_points(train_model_2, newdata = test) %>%
mutate(sq_residuals = residual^2) %>%
summarize(rmse = sqrt(mean(sq_residuals)))
house_prices_2 <- house_prices %>%
mutate(log10_price = log10(price), log10_size = log10(sqft_living))
house_prices <- house_prices_2
# View the structure of log10_price and waterfront
house_prices %>%
select(log10_price, waterfront) %>%
glimpse()
# Plot
ggplot(house_prices, aes(x = waterfront, y = log10_price)) +
geom_boxplot() +
labs(x = "waterfront", y = "log10 price")
knitr::opts_chunk$set(echo = TRUE)
options(repos="https://CRAN.R-project.org")
library(openintro)
mario_kart <- mariokart
str(mario_kart)
library(openintro)
mario_kart <- mariokart
# Explore the data
glimpse(mario_kart)
library(openintro)
library(dplyr)
mario_kart <- mariokart
# Explore the data
glimpse(mario_kart)
# fit parallel slopes
lm(total_pr ~ wheels + cond, data = mario_kart)
mod <- lm(total_pr ~ wheels + cond, data = mario_kart)
# Augment the model
augmented_mod <- augment(mod)
library(broom)
library(ggplot2)
mod <- lm(total_pr ~ wheels + cond, data = mario_kart)
# Augment the model
augmented_mod <- augment(mod)
glimpse(augmented_mod)
# scatterplot, with color
data_space <- ggplot(augmented_mod, aes(x = wheels, y = totalPr, color = cond)) +
geom_point()
# single call to geom_line()
data_space +
geom_line(aes(y = .fitted))
library(broom)
library(ggplot2)
mod <- lm(total_pr ~ wheels + cond, data = mario_kart)
# Augment the model
augmented_mod <- augment(mod)
glimpse(augmented_mod)
# scatterplot, with color
data_space <- ggplot(augmented_mod, aes(x = wheels, y = total_pr, color = cond)) +
geom_point()
# single call to geom_line()
data_space +
geom_line(aes(y = .fitted))
library(openintro)
library(dplyr)
mario_kart <- mariokart %>% filter(total_pr < 100)
# Explore the data
glimpse(mario_kart)
# fit parallel slopes
lm(total_pr ~ wheels + cond, data = mario_kart)
library(broom)
library(ggplot2)
mod <- lm(total_pr ~ wheels + cond, data = mario_kart)
# Augment the model
augmented_mod <- augment(mod)
glimpse(augmented_mod)
# scatterplot, with color
data_space <- ggplot(augmented_mod, aes(x = wheels, y = total_pr, color = cond)) +
geom_point()
# single call to geom_line()
data_space +
geom_line(aes(y = .fitted))
# build model
lm(bwt ~ age + parity, data = babies)
# build model
lm(bwt ~ gestation + smoke, data = babies)
# R^2 and adjusted R^2
summary(mod)
# add random noise
mario_kart_noisy <- mario_kart %>%
mutate(noise = rnorm(nrow(mario_kart)))
# compute new model
mod2 <- lm(total_pr ~ wheels + cond + noise, data = mario_kart_noisy)
# new R^2 and adjusted R^2
summary(mod2)
mario_kart_noisy
mario_kart_noisy$noise
?rnorm
# return a vector
predict(mod)
# return a data frame
augment(mod)
# include interaction
lm(total_pr ~ duration + cond + cond:duration, data = mario_kart)
# interaction plot
ggplot(mario_kart, aes(y = total_pr, x = duration, color = cond)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
slr <- ggplot(mario_kart, aes(y = total_pr, x = duration)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE)
# model with one slope
lm(total_pr ~ duration, data = mario_kart)
# plot with two slopes
slr + aes(color = cond)
glimpse(mario_kart)
# Fit the model using duration and startPr
lm(total_pr ~ duration + start_pr, data = mario_kart)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 1),
start_pr = seq_range(duration, by = 1)
)
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 1),
start_pr = seq_range(duration, by = 1)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
mod
# Fit the model using duration and startPr
(mod <- lm(total_pr ~ duration + start_pr, data = mario_kart))
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 1),
start_pr = seq_range(duration, by = 1)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
# tile the plane
data_space +
geom_tile(data = price_hats, aes(fill = .fitted), alpha = 0.5)
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 1),
start_pr = seq_range(start_pr, by = 1)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
# tile the plane
data_space +
geom_tile(data = price_hats, aes(fill = .fitted), alpha = 0.5)
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 10),
start_pr = seq_range(start_pr, by = 10)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
# tile the plane
data_space +
geom_tile(data = price_hats, aes(fill = .fitted), alpha = 0.5)
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = .1),
start_pr = seq_range(start_pr, by = .1)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
# tile the plane
data_space +
geom_tile(data = price_hats, aes(fill = .fitted), alpha = 0.5)
library(modelr)
data_space <- ggplot(mario_kart, aes(x = duration, y = start_pr)) +
geom_point(aes(color = total_pr))
grid <- mario_kart %>%
data_grid(
duration = seq_range(duration, by = 1),
start_pr = seq_range(start_pr, by = 1)
)
# add predictions to grid
price_hats <- augment(mod, newdata = grid)
# tile the plane
data_space +
geom_tile(data = price_hats, aes(fill = .fitted), alpha = 0.5)
mario_kart$duration
mario_kart$start_pr
mod
seq(from = 1, to = 10, by = 9/69)
seq(from = 0, to = 70, by = 70/69)
seq(from = 0.01, to = 69.95, by = 69.94/68.95)
seq(from = 0.01, to = 69.95, by = 70/69)
seq(from = 0.01, to = 69.95, by = 1)
seq(from = 0.01, to = 69.95, by = 1.013623)
70/69
69.94/69
seq(from = 0.01, to = 69.95, by = 69.94/69)
x <- seq(from = 1, to = 10, by = 9/69)
y <- seq(from = 0.01, to = 69.95, by = 69.94/69)
data_frame(duration = x, start_pr = y)
xy_tibble <- tibble(duration = x, start_pr = y)
augment(mod, newdata = xy_tibble)
outer(x, y, function(a, b){summary(mod)$coef[1,1] +
summary(mod)$coef[2,1]*a + summary(mod)$coef[3,1]*b})
summary(mod)$coef[1,1]
summary(mod)
mod$coefficients
mod$coefficients[1,1]
mod$coefficients[[1]]
mod$coefficients[[2]]]
mod$coefficients[[2]]
library(plotly)
x <- seq(from = 1, to = 10, by = 9/69)
y <- seq(from = 0.01, to = 69.95, by = 69.94/69)
plane <- outer(x, y, function(a, b){mod$coefficients[[1]] + mod$coefficients[[2]]*a + mod$coefficients[[3]]*b})
# draw the 3D scatterplot
p <- plot_ly(data = mario_kart, z = ~total_pr, x = ~duration, y = ~start_pr, opacity = 0.6) %>%
add_markers()
# draw the plane
p %>%
add_surface(x = ~x, y = ~y, z = ~plane, showscale = FALSE)
